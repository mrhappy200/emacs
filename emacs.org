#+title: My(@username@) Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle yes

* Basic setup
We are going to turn off the startup message, enable a bell for when we hit file borders, remove unnessesary UI elements, and enable line numbers
#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        visible-bell t)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (blink-cursor-mode -1)
  		   
  (global-display-line-numbers-mode 1)
  (use-package vterm
    :ensure t)
#+end_src

* Theme
#+begin_src emacs-lisp
(load-theme 'modus-vivendi t)
#+end_src

* EVIL mode
#+begin_src emacs-lisp
(use-package evil
  :ensure t ;; install the evil package if not installed
  :init ;; tweak evil's configuration before loading it
  (setq evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)
  :config ;; tweak evil after loading it
  (evil-mode)

#+end_src
** EVIL keybindings
This is where we define EVIL keybinds which are just so much better for text editing, if a little worse for accessing Emacs' more advanced functionality.
#+begin_src emacs-lisp
    ;; example how to map a command in normal mode (called 'normal state' in evil)
    (define-key evil-normal-state-map (kbd "<leader>wsv") 'evil-window-vsplit)
    (use-package evil-leader
      :ensure t
      :config
      (global-evil-leader-mode)))
#+end_src

** Org mode
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((dot . t))) ; this line activates dot
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
#+end_src

#+RESULTS:
| my/fix-inline-images |

#+begin_src emacs-lisp
  ;; The `vertico' package applies a vertical layout to the minibuffer.
  ;; It also pops up the minibuffer eagerly so we can see the available
  ;; options without further interactions.  This package is very fast
  ;; and "just works", though it also is highly customisable in case we
  ;; need to modify its behaviour.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:cff33514-d3ac-4c16-a889-ea39d7346dc5
  (use-package vertico
    :ensure t
    :config
    (setq vertico-cycle t)
    (setq vertico-resize nil)
    (vertico-mode 1))

  ;; The `marginalia' package provides helpful annotations next to
  ;; completion candidates in the minibuffer.  The information on
  ;; display depends on the type of content.  If it is about files, it
  ;; shows file permissions and the last modified date.  If it is a
  ;; buffer, it shows the buffer's size, major mode, and the like.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:bd3f7a1d-a53d-4d3e-860e-25c5b35d8e7e
  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode 1))

  ;; The `orderless' package lets the minibuffer use an out-of-order
  ;; pattern matching algorithm.  It matches space-separated words or
  ;; regular expressions in any order.  In its simplest form, something
  ;; like "ins pac" matches `package-menu-mark-install' as well as
  ;; `package-install'.  This is a powerful tool because we no longer
  ;; need to remember exactly how something is named.
  ;;
  ;; Note that Emacs has lots of "completion styles" (pattern matching
  ;; algorithms), but let us keep things simple.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:7cc77fd0-8f98-4fc0-80be-48a758fcb6e2
  (use-package orderless
    :ensure t
    :config
    (setq completion-styles '(orderless basic)))

  ;; The `consult' package provides lots of commands that are enhanced
  ;; variants of basic, built-in functionality.  One of the headline
  ;; features of `consult' is its preview facility, where it shows in
  ;; another Emacs window the context of what is currently matched in
  ;; the minibuffer.  Here I define key bindings for some commands you
  ;; may find useful.  The mnemonic for their prefix is "alternative
  ;; search" (as opposed to the basic C-s or C-r keys).
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:22e97b4c-d88d-4deb-9ab3-f80631f9ff1d
  (use-package consult
    :ensure t
    :bind (;; A recursive grep
           ("M-s M-g" . consult-grep)
           ;; Search for files names recursively
           ("M-s M-f" . consult-find)
           ;; Search through the outline (headings) of the file
           ("M-s M-o" . consult-outline)
           ;; Search the current buffer
           ("M-s M-l" . consult-line)
           ;; Switch to another buffer, or bookmarked file, or recently
           ;; opened file.
           ("M-s M-b" . consult-buffer)))

  ;; The `embark' package lets you target the thing or context at point
  ;; and select an action to perform on it.  Use the `embark-act'
  ;; command while over something to find relevant commands.
  ;;
  ;; When inside the minibuffer, `embark' can collect/export the
  ;; contents to a fully fledged Emacs buffer.  The `embark-collect'
  ;; command retains the original behaviour of the minibuffer, meaning
  ;; that if you navigate over the candidate at hit RET, it will do what
  ;; the minibuffer would have done.  In contrast, the `embark-export'
  ;; command reads the metadata to figure out what category this is and
  ;; places them in a buffer whose major mode is specialised for that
  ;; type of content.  For example, when we are completing against
  ;; files, the export will take us to a `dired-mode' buffer; when we
  ;; preview the results of a grep, the export will put us in a
  ;; `grep-mode' buffer.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:61863da4-8739-42ae-a30f-6e9d686e1995
  (use-package embark
    :ensure t
    :bind (("C-." . embark-act)
           :map minibuffer-local-map
           ("C-c C-c" . embark-collect)
           ("C-c C-e" . embark-export)))

  ;; The `embark-consult' package is glue code to tie together `embark'
  ;; and `consult'.
  (use-package embark-consult
    :ensure t)

  ;; The `wgrep' packages lets us edit the results of a grep search
  ;; while inside a `grep-mode' buffer.  All we need is to toggle the
  ;; editable mode, make the changes, and then type C-c C-c to confirm
  ;; or C-c C-k to abort.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:9a3581df-ab18-4266-815e-2edd7f7e4852
  (use-package wgrep
    :ensure t
    :bind ( :map grep-mode-map
            ("e" . wgrep-change-to-wgrep-mode)
            ("C-x C-q" . wgrep-change-to-wgrep-mode)
            ("C-c C-c" . wgrep-finish-edit)))

  ;; The built-in `savehist-mode' saves minibuffer histories.  Vertico
  ;; can then use that information to put recently selected options at
  ;; the top.
  ;;
  ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:25765797-27a5-431e-8aa4-cc890a6a913a
  (savehist-mode 1)

  ;; The built-in `recentf-mode' keeps track of recently visited files.
  ;; You can then access those through the `consult-buffer' interface or
  ;; with `recentf-open'/`recentf-open-files'.
  ;;
  ;; I do not use this facility, because the files I care about are
  ;; either in projects or are bookmarked.
  (recentf-mode 1)
#+end_src

* Org mode setup
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
    #+end_src
